

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: components/draggableElement.ts</title>

    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="./build/entry.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
    <link type="text/css" rel="stylesheet" href="styles/iframe.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                    
                    
                        <h1 class="navbar-item">Documentation</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="ApiRequester.html">ApiRequester</a></li><li><a href="BoardListController.html">BoardListController</a></li><li><a href="Boards.html">Boards</a></li><li><a href="ContentFormatter.html">ContentFormatter</a></li><li><a href="Draggable.html">Draggable</a></li><li><a href="TasklistController.html">TasklistController</a></li></ul><h3>Interfaces</h3><ul><li><a href="IDialogInputs.html">IDialogInputs</a></li><li><a href="IDialogTemplate.html">IDialogTemplate</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addBoardDialog">addBoardDialog</a></li><li><a href="global.html#addTask">addTask</a></li><li><a href="global.html#addTaskDialog">addTaskDialog</a></li><li><a href="global.html#Board">Board</a></li><li><a href="global.html#BoardHubConnection">BoardHubConnection</a></li><li><a href="global.html#createURLSearchParams">createURLSearchParams</a></li><li><a href="global.html#customElement">customElement</a></li><li><a href="global.html#editTaskDialog">editTaskDialog</a></li><li><a href="global.html">format</a></li><li><a href="global.html">formatWithMarkdown</a></li><li><a href="global.html#loadBoard">loadBoard</a></li><li><a href="global.html#loadDialogs">loadDialogs</a></li><li><a href="global.html#RequestParameter">RequestParameter</a></li><li><a href="global.html#send">send</a></li><li><a href="global.html#setupDialog">setupDialog</a></li><li><a href="global.html#shareDialog">shareDialog</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>components/draggableElement.ts</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { LitElement, html, css, property, customElement } from 'lit-element';

/**
 * Lit-element that can be dragged and dropped. Needs a &lt;tasklist> parent
 * and a &lt;section> grandparent. Place a &lt;placeholder> element inside the section
 * and style it as you wish.
 */
@customElement('draggable-element')
export class Draggable extends LitElement {
    @property() movable = true;
    private placeholder = "placeholder";
    private mouseIsDown = false;
    private startPos = {X: 0, Y: 0};
    private mouseDownPos = {X: 0, Y: 0};
    private detached = false;
    private lastHoveredDraggable: Draggable;
    private currentTasklist: HTMLElement;
    private currentIndex: number;

    static get styles() {
        return css`
      :host {
        display: block;
        -moz-user-select: none;
        user-select: none;
      }
    `;
    }

    render() {
        return html`&lt;slot>&lt;/slot>`;
    }

    firstUpdated(changedProperties) {
        let dragger = this.querySelector(".dragger");
        if (dragger == undefined) dragger = this;
        else dragger.addEventListener("click", () => this.mouseIsDown = false); // Otherwise it won't let go when you click

        dragger.addEventListener('mousedown', e => this.onMouseDown(e));
        this.addEventListener('click', e => this.onClick(e));
        document.body.addEventListener('mouseup', (e) => {
            if (this.detached) this.onMouseUp(this, e);
        });
        document.body.addEventListener('mousemove', e => {
            if (this.mouseIsDown) this.onMouseMove(e);
        });
        this.addEventListener("mousedown", e => { // Save mouse coordinates when mouse down anywhere on element
            this.mouseDownPos = {
                X: e.clientX,
                Y: e.clientY
            };
        });
    }

    private onMouseDown(e): void {
        this.mouseIsDown = true &amp;&amp; this.movable;
        this.startPos = {
            X: e.clientX - this.getBoundingClientRect().left,
            Y: e.clientY - this.getBoundingClientRect().top
        };

        this.currentTasklist = this.parentElement;
        this.currentIndex = this.getArrayItemIndex(this.parentElement.children, this);
    }

    private onClick(e): void {
        this.mouseIsDown = false;
        if (e.target != this &amp;&amp; e.target.parentElement != this) // Ignore if it's a grand-child
            return;

        // If mouse is at same position as before, it's just a click.
        // Fire the "draggableClick" event, since a normal click event also fires
        // even when the element has been dragged.
        if (this.mouseDownPos.X == e.clientX &amp;&amp;
            this.mouseDownPos.Y == e.clientY) {
            this.dispatchEvent(new CustomEvent("draggableClick"));
        }
    }

    private onMouseUp(element: Draggable, e): void {
        element.mouseIsDown = false;

        // Attach element
        element.style.position = "";
        element.style.width = "";
        element.style.top = "";
        element.style.left = "";

        // Move to placeholder
        const placeholder: HTMLElement = this.currentTasklist.parentElement.querySelector(this.placeholder);
        const targetTasklist = placeholder.parentElement;
        const targetIndex = this.getArrayItemIndex(placeholder.parentElement.children, placeholder);

        placeholder.parentElement.insertBefore(element, placeholder);
        placeholder.style.display = "none";
        element.detached = false;

        if (this.currentTasklist != targetTasklist) { // If moved to another tasklist
            this.dispatchEvent(new CustomEvent("taskExternalMove", {
                "detail": {
                    fromTasklist: this.currentTasklist,
                    toTasklist: targetTasklist,
                    toIndex: targetIndex,
                    toItem: this.previousElementSibling
                }
            }));
        } else if (this.currentIndex != targetIndex) { // If moved within the same tasklist.
            this.dispatchEvent(new CustomEvent("taskInternalMove", {
                "detail": {
                    fromIndex: this.currentIndex,
                    toIndex: targetIndex,
                    toItem: this.previousElementSibling
                }
            }));
        }
    }

    private onMouseMove(e): void {
        if (e.buttons != 1) return; // If left-click mouse button is not being held down, return

        // Detach from list
        if (!this.detached) {
            const computedStyle = getComputedStyle(this);
            // Placeholder
            const placeholder: HTMLElement = this.parentElement.parentElement.querySelector(this.placeholder);
            this.parentElement.insertBefore(placeholder, this); // Move placeholder to list slot
            Object.assign(placeholder.style, {
                width: computedStyle.width,
                height: computedStyle.height,
                display: "block"
            });

            // Draggable
            this.parentElement.parentElement.appendChild(this); // Move task out from tasklists, then get position: fixed
            this.style.width = computedStyle.width;
            this.style.position = "fixed";
            this.detached = true;
        }

        const parentRect = this.parentElement.parentElement.getBoundingClientRect();
        const newPos = {
            X: e.clientX - this.startPos.X - parentRect.left - 20,
            Y: e.clientY - this.startPos.Y - parentRect.top
        }

        this.style.left = newPos.X + "px";
        this.style.top = newPos.Y + "px";

        // Show where item will be dropped
        const elementsUnder = this.getRelatedElementsUnder();
        const placeholder: HTMLElement = this.parentElement.parentElement.querySelector(this.placeholder);
        const tasklistElements = elementsUnder.tasklist.children;
        let lastRect = undefined;
        if (tasklistElements.length > 0 )
            lastRect = tasklistElements[tasklistElements.length - 1].getBoundingClientRect(); // Get last element in tasklist if not empty
        if (elementsUnder.tasklist == undefined) return;

        // If a draggable is under, and the placeholder wasn't already inserted there
        if (elementsUnder.closestDraggable != undefined &amp;&amp; elementsUnder.closestDraggable != this) {
            const overTopHalf = elementsUnder.middlePoint.Y &lt;= this.getMiddlePoint(elementsUnder.closestDraggable).Y;

            // If over the top half of the element
            if  (overTopHalf &amp;&amp; this.lastHoveredDraggable != elementsUnder.closestDraggable) {
                elementsUnder.tasklist.insertBefore(placeholder, elementsUnder.closestDraggable);
                this.lastHoveredDraggable = elementsUnder.closestDraggable as Draggable; // Remember last placement
            } else if (this.lastHoveredDraggable != elementsUnder.closestDraggable.nextSibling) { // If over the bottom half of the element
                elementsUnder.tasklist.insertBefore(placeholder, elementsUnder.closestDraggable.nextSibling);
                this.lastHoveredDraggable = elementsUnder.closestDraggable.nextSibling as Draggable;
            }
        } else if (lastRect == undefined) { // If empty tasklist
            elementsUnder.tasklist.appendChild(placeholder);
        } else if (this.getMiddlePoint().Y > lastRect.top + lastRect.height) {  // If at bottom
            elementsUnder.tasklist.appendChild(placeholder);
        }
    }

    /**
     * Get &lt;draggable> element under the element currently being dragged, and 
     * also the hovered tasklist.
     */
    private getRelatedElementsUnder() {
        const middlePoint = this.getMiddlePoint();
        const elementsOnPoint = document.elementsFromPoint(middlePoint.X, middlePoint.Y);
        let   closestDraggable = elementsOnPoint.filter(x => x.tagName == "DRAGGABLE-ELEMENT")[1];
        const tasklist = elementsOnPoint.filter(x => x.tagName == "TASKLIST")[0];

        if (tasklist &amp;&amp; !closestDraggable) {
            const under = document.elementsFromPoint(middlePoint.X, middlePoint.Y + 40)
                .filter(x => x.tagName == "DRAGGABLE-ELEMENT");

            if (under[1] == undefined) closestDraggable = under[0];
            else closestDraggable = under[1];
        }

        return { closestDraggable, tasklist, middlePoint };
    }

    /**
     * Get the global coordinates of the elements middle point.
     * @param   {element} element The element to get the middle point of
     */
    private getMiddlePoint(element: Element = this) {
        const rect = element.getBoundingClientRect();
        return {
            X: rect.width / 2 + rect.left,
            Y: rect.height / 2 + rect.top
        };
    }

    /**
     * Get the index of a specific item in an array
     * @param array Array containing the item
     * @param item The item of which the index is being found
     */
    private getArrayItemIndex(array, item): number {
        return Array.from(array).indexOf(item);
    }
}
</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>


<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Fri Dec 27 2019 22:43:06 GMT+0100 (Central European Standard Time)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
        </p>
    </div>
</footer>


<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
